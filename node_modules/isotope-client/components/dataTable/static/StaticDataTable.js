'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _TableExampleComplex = require('./../TableExampleComplex');

var _TableExampleComplex2 = _interopRequireDefault(_TableExampleComplex);

var _reselect = require('reselect');

var _comparators = require('./comparators');

var _comparators2 = _interopRequireDefault(_comparators);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var getHeaders = function getHeaders(headers, sort) {
	if (sort.length) {
		// TODO gérer la priorité des tris (ex: d'abord le nom, puis le prénom, etc.)
		return headers.map(function (header) {
			var matchSort = sort.filter(function (_sort) {
				return header.key === _sort.property;
			});
			if (matchSort.length > 0) {
				return _extends({}, header, {
					sorted: matchSort[0].direction
				});
			}
			return header;
		});
	}
	return headers;
};

/**
 * @param data un tableau contenant toutes les données qu'il est possible d'afficher
 * @param page le numéro de la page à afficher (commence à 1)
 * @param pageSize le nombre d'éléments par page à afficher
 * @param sort le tri à appliquer sur les données
 * @param headers un tableau contenant les définitions des en-têtes du tableau (pour le tri)
 * @param filter le filtre à appliquer sur les données
 * @returns {{data: Array, page: number, pageSize: *, firstPage: boolean, lastPage: boolean, totalElements: Number, totalPages: number, sort: *}}
 */
var selectData = function selectData() {
	var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var page = arguments[1];
	var pageSize = arguments[2];
	var sort = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
	var headers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
	var filter = arguments[5];


	var realData = data;
	// on commence par filter les données
	if (filter) {
		realData = realData.filter(filter);
	}

	// le nombre total d'éléments après application du filtre
	var totalElements = realData.length;
	// le nombre total de pages en fonction du nombre d'éléments par page demandés
	var totalPages = Math.ceil(totalElements / pageSize);
	// ajustement de la page demandée en fonction du nombre de pages total
	var realPage = Math.min(page, totalPages);

	if (sort.length > 0) {
		// pour l'instant on ne supporte qu'un seul tri
		var sort1 = sort[0];
		// récupération du header correspondant à la colonne pour déterminer la nature du tri à appliquer
		var header = headers.find(function (header) {
			return header.key === sort1.property;
		});
		if (header) {
			realData = realData.sort(function (row1, row2) {
				// l'ordre du tri
				var direction = sort1.direction === 'DESC' ? -1 : 1;
				if (header.compare) {
					// si le header fournit une méthode de tri, on l'applique SUR LES LIGNES
					return direction * header.compare(row1, row2);
				}
				// sinon, on se rabat sur les tris standards SUR LES VALEURS
				var v1 = row1[sort1.property];
				var v2 = row2[sort1.property];
				return direction * (0, _comparators2.default)(header.type)(v1, v2);
			});
		}
	}

	var start = (realPage - 1) * pageSize;
	var end = Math.min(start + pageSize, totalElements);
	realData = realData.slice(start, end);

	return {
		data: realData,
		page: realPage,
		pageSize: pageSize,
		firstPage: realPage === 1,
		lastPage: end === totalElements,
		totalElements: totalElements,
		totalPages: totalPages,
		// TODO fix dans datatable
		sort: sort.length > 0 ? sort : null
	};
};

// selectors
var dataSelector = function dataSelector(state, props) {
	return props.data;
};
var pageSelector = function pageSelector(state) {
	return state.page;
};
var pageSizeSelector = function pageSizeSelector(state) {
	return state.pageSize;
};
var sortSelector = function sortSelector(state) {
	return state.sort;
};
var headersSelector = function headersSelector(state, props) {
	return props.headers;
};
var filterSelector = function filterSelector(state, props) {
	return props.filter;
};
var selectedDataSelector = (0, _reselect.createSelector)([dataSelector, pageSelector, pageSizeSelector, sortSelector, headersSelector, filterSelector], selectData);

var StaticDataTable = function (_PureComponent) {
	_inherits(StaticDataTable, _PureComponent);

	function StaticDataTable(props) {
		_classCallCheck(this, StaticDataTable);

		var _this = _possibleConstructorReturn(this, (StaticDataTable.__proto__ || Object.getPrototypeOf(StaticDataTable)).call(this, props));

		_this.state = {
			data: {},
			page: 1,
			pageSize: props.defaultPageSize || 20,
			sort: []
		};

		_this.handlePageChange = _this.handlePageChange.bind(_this);
		_this.handleElementsPerPageChange = _this.handleElementsPerPageChange.bind(_this);
		_this.handleFilterChange = _this.handleFilterChange.bind(_this);
		return _this;
	}

	_createClass(StaticDataTable, [{
		key: 'handlePageChange',
		value: function handlePageChange(newPage) {
			this.setState({
				page: newPage
			});
		}
	}, {
		key: 'handleElementsPerPageChange',
		value: function handleElementsPerPageChange(newPageSize) {
			var page = this.state.page;
			var data = this.props.data;

			var newTotalPages = Math.ceil(data.length / newPageSize);
			this.setState({
				page: Math.min(page, newTotalPages),
				pageSize: newPageSize
			});
		}
	}, {
		key: 'handleFilterChange',
		value: function handleFilterChange(property, direction) {
			// TODO sort multiples
			this.setState({
				sort: [{
					property: property,
					direction: direction
				}]
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var sort = this.state.sort;

			var _props = this.props,
			    data = _props.data,
			    headers = _props.headers,
			    otherProps = _objectWithoutProperties(_props, ['data', 'headers']);

			var computedHeaders = getHeaders(headers, sort);
			var selectedData = selectedDataSelector(this.state, this.props);
			return _react2.default.createElement(_TableExampleComplex2.default, _extends({}, otherProps, selectedData, {
				headers: computedHeaders,
				onPageChange: this.handlePageChange,
				onElementsPerPageChange: this.handleElementsPerPageChange,
				onFilterChange: this.handleFilterChange,
				onRowSelection: function onRowSelection(selection) {
					var onRowSelection = _this2.props.onRowSelection;

					if (onRowSelection) {
						if (selection === 'all') {
							onRowSelection(selection);
						} else if (selection === 'none') {
							onRowSelection([]);
						} else {
							onRowSelection(data.filter(function (el, idx) {
								return selection.indexOf(idx) >= 0;
							}));
						}
					}
				}
			}));
		}
	}]);

	return StaticDataTable;
}(_react.PureComponent);

StaticDataTable.propTypes = {
	/**
  * Les données à afficher.
  */
	data: _react.PropTypes.array.isRequired,
	/**
  * Définitions des colonnes.
  */
	headers: _react.PropTypes.array.isRequired,
	/**
  * Fonction filtrant les données initiales.
  */
	filter: _react.PropTypes.func,
	onRowSelection: _react.PropTypes.func,
	/**
  * Le nombre d'éléments affichés à l'initialisation.
  */
	defaultPageSize: _react.PropTypes.number
};

exports.default = StaticDataTable;