'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactRedux = require('react-redux');

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _TextField = require('material-ui/TextField');

var _TextField2 = _interopRequireDefault(_TextField);

var _Paper = require('material-ui/Paper');

var _Paper2 = _interopRequireDefault(_Paper);

var _List = require('material-ui/List');

var _domScrollIntoView = require('dom-scroll-into-view');

var _domScrollIntoView2 = _interopRequireDefault(_domScrollIntoView);

var _colorManipulator = require('material-ui/utils/colorManipulator');

var _actions = require('./actions');

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Autocomplete = function (_Component) {
	_inherits(Autocomplete, _Component);

	function Autocomplete(props) {
		_classCallCheck(this, Autocomplete);

		var _this = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, props));

		_this._ignoreBlur = false;
		_this._performAutoCompleteOnUpdate = false;
		_this._performAutoCompleteOnKeyUp = false;

		_this.state = {
			menuTop: 0,
			menuLeft: 0,
			menuWidth: 0
		};
		return _this;
	}

	_createClass(Autocomplete, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			this.props.dispatch(actions.init({ props: this.exportProps() }));
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			if (this.props.isOpen === true && prevProps.isOpen === false) {
				this.setMenuPositions();
			}

			if (this.props.isOpen && this._performAutoCompleteOnUpdate) {
				this._performAutoCompleteOnUpdate = false;
				this.maybeAutoCompleteText();
			}

			this.maybeScrollItemIntoView();
		}
	}, {
		key: 'exportProps',
		value: function exportProps() {
			var _props = this.props,
			    staticItems = _props.staticItems,
			    getItemValue = _props.getItemValue,
			    shouldItemRender = _props.shouldItemRender,
			    sortItems = _props.sortItems,
			    sortGroups = _props.sortGroups,
			    name = _props.name,
			    text = _props.text;

			return { staticItems: staticItems, getItemValue: getItemValue, shouldItemRender: shouldItemRender, sortItems: sortItems, sortGroups: sortGroups, name: name, text: text };
		}
	}, {
		key: 'maybeScrollItemIntoView',
		value: function maybeScrollItemIntoView() {
			if (this.props.isOpen === true && this.props.highlightedIndex !== null) {
				var itemNode = _reactDom2.default.findDOMNode(this.refs['item-' + this.props.highlightedIndex]);
				var menuNode = _reactDom2.default.findDOMNode(this.refs.menu);
				itemNode && (0, _domScrollIntoView2.default)(itemNode, menuNode, { onlyScrollIfNeeded: true });
			}
		}
	}, {
		key: 'handleKeyDown',
		value: function handleKeyDown(event) {
			if (Autocomplete.keyDownHandlers[event.key]) {
				Autocomplete.keyDownHandlers[event.key].call(this, event);
			}
		}
	}, {
		key: 'handleChange',
		value: function handleChange(event) {
			var _this2 = this;

			this._performAutoCompleteOnKeyUp = true;
			var payload = this.exportProps();
			payload.text = event.target.value;
			this.props.dispatch(actions.setText({ props: payload }));

			if (this.launchedSearch) {
				window.clearTimeout(this.launchedSearch);
			}

			this.launchedSearch = setTimeout(function () {
				_this2.props.onChange(payload.text, _this2.props.name, _this2.props.dispatch);
			}, 400);
		}
	}, {
		key: 'handleKeyUp',
		value: function handleKeyUp() {
			if (this._performAutoCompleteOnKeyUp) {
				this._performAutoCompleteOnKeyUp = false;
				this.maybeAutoCompleteText();
			}
		}
	}, {
		key: 'maybeAutoCompleteText',
		value: function maybeAutoCompleteText() {
			var _props2 = this.props,
			    text = _props2.text,
			    highlightedIndex = _props2.highlightedIndex,
			    getItemValue = _props2.getItemValue;

			if (text === '') {
				return;
			}
			var items = this.props.items;
			if (items.length === 0) {
				return;
			}
			var matchedItem = highlightedIndex !== null ? items[highlightedIndex] : items[0];
			var itemValue = getItemValue(matchedItem);
			var itemValueDoesMatch = itemValue && itemValue.toLowerCase().indexOf(text.toLowerCase()) === 0;
			if (itemValueDoesMatch) {
				if (highlightedIndex === null) {
					this.highlightItemFromMouse(matchedItem, 0);
				}
				var node = _reactDom2.default.findDOMNode(this.refs.input);
				node.value = itemValue;
				/*node.setSelectionRange(text.length, itemValue.length)*/
			}
		}
	}, {
		key: 'setMenuPositions',
		value: function setMenuPositions() {
			var node = _reactDom2.default.findDOMNode(this.refs.input);
			var rect = node.getBoundingClientRect();
			var computedStyle = getComputedStyle(node);
			var marginBottom = parseInt(computedStyle.marginBottom, 10);
			var marginLeft = parseInt(computedStyle.marginLeft, 10);
			var marginRight = parseInt(computedStyle.marginRight, 10);
			this.setState({
				menuTop: marginBottom,
				menuLeft: marginLeft,
				menuWidth: rect.width + marginLeft + marginRight
			});
		}
	}, {
		key: 'highlightItemFromMouse',
		value: function highlightItemFromMouse(item, index) {
			this.props.dispatch(actions.setHighlight({ index: index, name: this.props.name }));
		}
	}, {
		key: 'selectItemFromMouse',
		value: function selectItemFromMouse(item, index) {
			var _props3 = this.props,
			    onSelect = _props3.onSelect,
			    getItemValue = _props3.getItemValue,
			    dispatch = _props3.dispatch,
			    name = _props3.name,
			    noclearOnSelect = _props3.noclearOnSelect;

			var value = getItemValue(item);
			if (noclearOnSelect) {
				dispatch(actions.selectItem({ index: index, isOpen: true, props: this.exportProps() }));
				var items = this.props.items.filter(function (tempItem) {
					return tempItem !== item;
				});
				dispatch(actions.setItems({ name: name, items: items }));
			} else {
				dispatch(actions.selectItem({ index: index, props: this.exportProps() }));
				dispatch(actions.clearItems({ name: name }));
			}
			onSelect(value, item);
			this.setIgnoreBlur(false);
		}
	}, {
		key: 'setIgnoreBlur',
		value: function setIgnoreBlur(ignore) {
			this._ignoreBlur = ignore;
		}
	}, {
		key: 'renderItem',
		value: function renderItem(item, highlighted, hoverColor) {
			return _react2.default.createElement(_List.ListItem, {
				style: highlighted ? { backgroundColor: hoverColor } : {},
				disableKeyboardFocus: true,
				key: item.id,
				value: item.label,
				primaryText: item.label
			});
		}
	}, {
		key: 'renderMenu',
		value: function renderMenu(hoverColor) {
			var _this3 = this;

			var group = void 0;
			var items = this.props.items.map(function (item, index) {
				var element = _this3.renderItem(item, _this3.props.highlightedIndex === index, hoverColor);
				var header = void 0;
				if (item.group && group !== item.group) {
					header = _react2.default.createElement(
						'div',
						{ style: _this3.props.headerStyle },
						item.group
					);
					group = item.group;
				}
				return [header, _react2.default.cloneElement(element, {
					onMouseDown: function onMouseDown() {
						return _this3.setIgnoreBlur(true);
					},
					onMouseEnter: function onMouseEnter() {
						return _this3.highlightItemFromMouse(item, index);
					},
					onClick: function onClick() {
						return _this3.selectItemFromMouse(item, index);
					},
					ref: 'item-' + index
				})];
			}).reduce(function (list, ary) {
				return list.concat(ary.filter(function (i) {
					return !!i;
				}));
			}, []);
			var style = {
				left: this.state.menuLeft,
				top: this.state.menuTop,
				minWidth: this.state.menuWidth
			};

			var menu = this.props.renderMenu(items, this.props.text, style);
			return _react2.default.cloneElement(menu, { ref: 'menu' });
		}
	}, {
		key: 'handleInputBlur',
		value: function handleInputBlur() {
			if (this._ignoreBlur) {
				return;
			}
			this.props.dispatch(actions.closeList({ name: this.props.name }));
		}
	}, {
		key: 'handleInputFocus',
		value: function handleInputFocus(event) {
			if (this._ignoreBlur) {
				return;
			}
			var payload = this.exportProps();
			this.props.dispatch(actions.openList({ props: payload }));
			if (this.props.onFocus) {
				this.props.onFocus(event, event.target.value, this.props.name);
			}
		}
	}, {
		key: 'handleInputClick',
		value: function handleInputClick() {
			if (this.props.isOpen === false) {
				this.props.dispatch(actions.openList({ props: this.exportProps() }));
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this4 = this;

			var style = { display: 'inline-block', position: 'relative' };
			var _props4 = this.props,
			    floatingLabelText = _props4.floatingLabelText,
			    name = _props4.name,
			    disabled = _props4.disabled;
			var muiTheme = this.context.muiTheme;

			var textColor = muiTheme.baseTheme.palette.textColor;
			var hoverColor = (0, _colorManipulator.fade)(textColor, 0.1);

			var value = this.props.text === '' ? '' : this.props.text || this.props.getItemValue(this.props.value) || '';

			return _react2.default.createElement(
				'div',
				{ style: this.props.fullWidth ? _extends({}, style, { width: '100%' }) : style },
				_react2.default.createElement(_TextField2.default, _extends({
					fullWidth: true
				}, this.props.inputProps, {
					floatingLabelText: floatingLabelText,
					name: name,
					role: 'combobox',
					'aria-autocomplete': 'both',
					autoComplete: 'off',
					ref: 'input',
					onFocus: this.handleInputFocus.bind(this),
					onBlur: this.handleInputBlur.bind(this),
					onChange: function onChange(event) {
						return _this4.handleChange(event);
					},
					onKeyDown: function onKeyDown(event) {
						return _this4.handleKeyDown(event);
					},
					onKeyUp: function onKeyUp(event) {
						return _this4.handleKeyUp(event);
					},
					onClick: this.handleInputClick.bind(this),
					value: value,
					errorText: (!this.props.isOpen || this.props.isOpen && this.props.items.length <= 0) && this.props.errorText,
					disabled: disabled
				})),
				this.props.isOpen && this.props.items.length > 0 && this.renderMenu(hoverColor)
			);
		}
	}]);

	return Autocomplete;
}(_react.Component);

Autocomplete.propTypes = {
	// Props from state tree
	text: _react.PropTypes.string.isRequired,
	isOpen: _react.PropTypes.bool.isRequired,
	highlightedIndex: _react.PropTypes.number,
	items: _react.PropTypes.array.isRequired,
	// Props from wrapper props
	name: _react.PropTypes.string.isRequired,
	floatingLabelText: _react.PropTypes.string,
	getItemValue: _react.PropTypes.func.isRequired,
	inputProps: _react.PropTypes.object,
	staticItems: _react.PropTypes.array,
	onChange: _react.PropTypes.func,
	onFocus: _react.PropTypes.func,
	onSelect: _react.PropTypes.func,
	shouldItemRender: _react.PropTypes.func,
	sortItems: _react.PropTypes.func,
	sortGroups: _react.PropTypes.func,
	menuStyle: _react.PropTypes.object,
	headerStyle: _react.PropTypes.object,
	fullWidth: _react.PropTypes.bool,
	disabled: _react.PropTypes.bool,
	noclearOnSelect: _react.PropTypes.bool,
	errorText: _react.PropTypes.string
};
Autocomplete.contextTypes = {
	muiTheme: _react.PropTypes.object.isRequired
};

Autocomplete.defaultProps = {
	inputProps: {},
	onChange: function onChange() {},
	onFocus: function onFocus() {},
	onSelect: function onSelect(value, item) {},
	renderMenu: function renderMenu(items, value, style) {
		return _react2.default.createElement(
			_Paper2.default,
			null,
			_react2.default.createElement(
				_List.List,
				{ disableAutoFocus: true },
				items
			)
		);
	},
	shouldItemRender: function shouldItemRender() {
		return true;
	},
	menuStyle: {
		top: '66px',
		zIndex: 3000,
		position: 'absolute'
	},
	headerStyle: {
		padding: '2px 6px',
		fontSize: '1.2em',
		backgroundColor: '#ddd'
	}
};

Autocomplete.keyDownHandlers = {
	ArrowDown: function ArrowDown(event) {
		// Make 'this' free
		event.preventDefault();
		var _props5 = this.props,
		    highlightedIndex = _props5.highlightedIndex,
		    dispatch = _props5.dispatch;

		var index = highlightedIndex === null || highlightedIndex === this.props.items.length - 1 ? 0 : highlightedIndex + 1;
		this._performAutoCompleteOnKeyUp = true;
		dispatch(actions.setHighlight({ index: index, name: this.props.name }));
	},

	ArrowUp: function ArrowUp(event) {
		// Make 'this' free
		event.preventDefault();
		var _props6 = this.props,
		    highlightedIndex = _props6.highlightedIndex,
		    dispatch = _props6.dispatch;

		var index = highlightedIndex === 0 || highlightedIndex === null ? this.props.items.length - 1 : highlightedIndex - 1;
		this._performAutoCompleteOnKeyUp = true;
		dispatch(actions.setHighlight({ index: index, name: this.props.name }));
	},

	Enter: function Enter(event) {
		// Make 'this' free
		var _props7 = this.props,
		    isOpen = _props7.isOpen,
		    highlightedIndex = _props7.highlightedIndex,
		    getItemValue = _props7.getItemValue,
		    text = _props7.text,
		    onSelect = _props7.onSelect,
		    dispatch = _props7.dispatch,
		    noclearOnSelect = _props7.noclearOnSelect,
		    name = _props7.name;

		if (isOpen === false) {
			// already selected this, do nothing
			return;
		} else if (highlightedIndex == null) {
			// hit enter after focus but before typing anything so no autocomplete attempt yet
			//dispatch(actions.closeList({ name: this.props.name }))
			//ReactDOM.findDOMNode(this.refs.input).select()
		} else {
			event.preventDefault();
			var item = this.props.items[highlightedIndex];
			var value = getItemValue(item);
			if (noclearOnSelect) {
				dispatch(actions.selectItem({ index: highlightedIndex, isOpen: true, props: this.exportProps() }));
				var items = this.props.items.filter(function (tempItem) {
					return tempItem !== item;
				});
				dispatch(actions.setItems({ name: name, items: items }));
			} else {
				dispatch(actions.selectItem({ index: highlightedIndex, props: this.exportProps() }));
				dispatch(actions.clearItems({ name: name }));
			}
			onSelect(value, item);
			this.setIgnoreBlur(false);
		}
	},

	Escape: function Escape(event) {
		// Make 'this' free
		this.props.dispatch(actions.closeList({ name: this.props.name }));
	},

	Backspace: function Backspace(event) {
		// Make 'this' free
		var node = _reactDom2.default.findDOMNode(this.refs.input);
		node.value = this.props.text;
	}
};

function select(state, ownProps) {
	var local = void 0;
	if (state.autocomplete.liste[ownProps.name]) {
		local = state.autocomplete.liste[ownProps.name];
	} else {
		local = state.autocomplete.base;
	}
	return _extends({}, local, ownProps);
}

exports.default = (0, _reactRedux.connect)(select)(Autocomplete);