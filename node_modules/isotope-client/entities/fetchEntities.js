'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.saveStore = saveStore;
exports.fetchFactory = fetchFactory;
exports.postMultipart = postMultipart;

var _flat = require('flat');

var _loginActions = require('../login/loginActions.js');

require('whatwg-fetch');

var _serialize = require('./serialize');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var defaultAdminApi = '/api/admin';

var Store = null;
function saveStore(createdStore) {
	Store = createdStore;
}

/**
 * Convertit les messages d'erreur reçus du serveur au format Intl.
 *
 * Petite subtilité pour l'attribut `values` qui doit être un Object.
 *
 * @param error
 */
var convertError = function convertError(error) {
	return {
		id: error.code || '__ERROR__',
		ids: error.codes,
		defaultMessage: error.defaultMessage,
		values: Object.assign({}, error.arguments, {
			rejectedValue: error.rejectedValue
		})
	};
};

var checkErrors = function checkErrors(_ref) {
	var _ref2 = _slicedToArray(_ref, 2),
	    response = _ref2[0],
	    json = _ref2[1];

	if (response.status === 400) {
		// conversion des erreurs

		// erreurs globales
		var globalErrors = (json.globalErrors || []).map(convertError).reduce(function (previousValue, currentValue) {
			return [].concat(_toConsumableArray(previousValue), [currentValue]);
		}, []);
		// erreurs sur les champs du formulaire

		var fieldErrors = (json.fieldErrors || []).map(function (error) {
			return _defineProperty({}, error.field.replace(/\[(\d)]/g, '.$1'), convertError(error));
		}).reduce(function (previousValue, currentValue) {
			return _extends({}, previousValue, currentValue);
		}, {});

		return Promise.reject(_extends({
			_error: globalErrors
		}, (0, _flat.unflatten)(fieldErrors), {
			response: response,
			bodyError: json
		}));
	}
	return json;
};

var handleResponse = function handleResponse(response) {
	// vérification du token
	if (response.status === 401) {
		// si le token n'est pas valide...
		return response.text().then(function (result) {
			// on déconnecte l'utilisateur
			Store.dispatch((0, _loginActions.logOut)());
			// et on rejette l'appel
			return Promise.reject(new Error(result));
		});
	}
	if (response.status === 204) {
		// no content
		return Promise.resolve();
	}
	if (!response.ok && response.status !== 400) {
		// si la réponse est en erreur sauf erreur de validation, on rejette l'appel
		return Promise.reject(response);
	}
	// dans tous les autres cas, la réponse est traitée en JSON
	return Promise.all([response, response.json()]).then(checkErrors);
};

function fetchFactory(path) {
	var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var apiUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAdminApi;

	var headers = config.headers,
	    others = _objectWithoutProperties(config, ['headers']);

	var token = localStorage.getItem('token') || null;
	var defaultHeaders = {
		Accept: 'application/json',
		'Content-Type': 'application/json;charset=utf-8'
	};
	if (token) {
		defaultHeaders.Authorization = token;
	}
	var newConfig = _extends({
		headers: _extends({}, defaultHeaders, headers)
	}, others);
	return fetch('' + SERVER_URL + apiUrl + path, newConfig) // eslint-disable-line no-undef
	.then(handleResponse);
}

function postMultipart(path) {
	var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var apiUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAdminApi;

	var token = localStorage.getItem('token') || null;

	var body = config.body,
	    headers = config.headers,
	    others = _objectWithoutProperties(config, ['body', 'headers']);

	var newConfig = _extends({
		method: 'POST',
		headers: _extends({
			Accept: 'application/json',
			Authorization: token
		}, headers),
		body: body instanceof FormData ? body : (0, _serialize.serializeFormValues)(body)
	}, others);
	return fetch('' + SERVER_URL + apiUrl + path, newConfig) // eslint-disable-line no-undef
	.then(handleResponse);
}